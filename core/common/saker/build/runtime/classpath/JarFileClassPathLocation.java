/*
 * Copyright (C) 2020 Bence Sipka
 *
 * This program is free software: you can redistribute it and/or modify 
 * it under the terms of the GNU General Public License as published by 
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package saker.build.runtime.classpath;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;
import java.security.MessageDigest;
import java.util.UUID;

import saker.build.file.path.ProviderHolderPathKey;
import saker.build.file.path.SakerPath;
import saker.build.file.provider.FileEntry;
import saker.build.file.provider.RootFileProviderKey;
import saker.build.file.provider.SakerFileProvider;
import saker.build.file.provider.SakerPathFiles;
import saker.build.thirdparty.saker.rmi.annot.transfer.RMIWrap;
import saker.build.thirdparty.saker.rmi.exception.RMIRuntimeException;
import saker.build.thirdparty.saker.rmi.io.RMIObjectInput;
import saker.build.thirdparty.saker.rmi.io.RMIObjectOutput;
import saker.build.thirdparty.saker.rmi.io.wrap.RMIWrapper;
import saker.build.thirdparty.saker.util.StringUtils;
import saker.build.thirdparty.saker.util.io.ByteArrayRegion;
import saker.build.thirdparty.saker.util.io.ByteSink;
import saker.build.thirdparty.saker.util.io.ByteSource;
import saker.build.thirdparty.saker.util.io.FileUtils;

/**
 * {@link ClassPathLocation} implementation backed by a JAR file at a given file system location.
 * <p>
 * The location is specified using a {@linkplain SakerFileProvider file provider} and {@linkplain SakerPath path}.
 * <p>
 * The {@linkplain #getIdentifier() identifier} is generated by creating a hash of the class name, root file provider
 * {@link UUID}, and file path. It is then prepended by the phrase <code>"jar/"</code>.
 */
@RMIWrap(JarFileClassPathLocation.LocationRMIWrapper.class)
public final class JarFileClassPathLocation implements ClassPathLocation {
	protected final SakerPath jarPath;
	protected final RootFileProviderKey rootFileProviderKey;

	protected final transient SakerFileProvider fileProvider;
	protected final transient String identifier;

	private JarFileClassPathLocation(SakerPath jarPath, RootFileProviderKey rootFileProviderKey,
			SakerFileProvider fileProvider, String identifier) {
		this.jarPath = jarPath;
		this.rootFileProviderKey = rootFileProviderKey;
		this.fileProvider = fileProvider;
		this.identifier = identifier;
	}

	/**
	 * Creates a new instance with a backing path key.
	 * 
	 * @param pathkey
	 *            The path key to the JAR file.
	 */
	public JarFileClassPathLocation(ProviderHolderPathKey pathkey) {
		this.rootFileProviderKey = pathkey.getFileProviderKey();
		SakerFileProvider fileProvider = pathkey.getFileProvider();
		this.fileProvider = fileProvider;
		this.jarPath = pathkey.getPath();
		MessageDigest hasher = FileUtils.getDefaultFileHasher();
		hasher.update(this.getClass().getName().getBytes());
		hasher.update(rootFileProviderKey.getUUID().toString().getBytes(StandardCharsets.UTF_8));
		byte[] hash = hasher.digest(jarPath.toString().getBytes(StandardCharsets.UTF_8));
		identifier = "jar/" + StringUtils.toHexString(hash);
	}

	/**
	 * Gets the file provider this location uses to load the JAR.
	 * 
	 * @return The file provider.
	 */
	public SakerFileProvider getFileProvider() {
		return fileProvider;
	}

	/**
	 * Gets the path to the JAR file in relation with the backing file provider.
	 * 
	 * @return The path to the JAR.
	 */
	public SakerPath getJarPath() {
		return jarPath;
	}

	@Override
	public ClassPathLoader getLoader() throws IOException {
		return new ClassPathLoader() {
			private FileEntry jarAttributes;

			@Override
			public SakerPath loadTo(ProviderHolderPathKey directory) throws IOException {
				//exports to
				//    target/directory/filename.jar
				//write to a temp file first and then move to the target location

				SakerPath targetdirpath = directory.getPath();
				SakerFileProvider targetfp = directory.getFileProvider();
				if (SakerPathFiles.isSubPath(targetfp, targetdirpath, fileProvider, jarPath)) {
					throw new IOException(
							"JAR to load is already in the target directory tree: " + jarPath + " in " + targetdirpath);
				}

				FileEntry jarattrs = fileProvider.getFileAttributes(jarPath);

				SakerPath targetjarpath = targetdirpath.resolve(jarPath.getFileName());
				SakerPath temptargetjarpath = targetdirpath.resolve(jarPath.getFileName() + "." + UUID.randomUUID());
				long sourcejarmodifiedmillis = jarattrs.getLastModifiedMillis();
				if (targetfp.isChanged(targetjarpath, jarattrs.size(), sourcejarmodifiedmillis)) {
					targetfp.createDirectories(targetdirpath);
					try (ByteSource in = fileProvider.openInput(jarPath)) {
						targetfp.writeToFile(in, temptargetjarpath, StandardOpenOption.CREATE_NEW);
					}
					targetfp.setLastModifiedMillis(temptargetjarpath, sourcejarmodifiedmillis);
					try {
						targetfp.moveFile(temptargetjarpath, targetjarpath, StandardCopyOption.REPLACE_EXISTING);
					} catch (IOException e) {
						//failed to move, clean up the temp file
						try {
							targetfp.delete(temptargetjarpath);
						} catch (IOException e2) {
							e.addSuppressed(e2);
						}
						throw e;
					}

					try (ByteSink origintxt = targetfp.openOutput(targetdirpath.resolve("origin.txt"))) {
						origintxt.write(
								ByteArrayRegion.wrap(("Jar origin:\nRootFileProvider: " + rootFileProviderKey.getUUID()
										+ "\nPath: " + jarPath).getBytes(StandardCharsets.UTF_8)));
					} catch (IOException e) {
						//ignoreable
					}
				}
				this.jarAttributes = jarattrs;
				return targetdirpath.relativize(targetjarpath);
			}

			@Override
			public boolean isChanged() {
				try {
					return fileProvider.isChanged(jarPath, jarAttributes.getSize(),
							jarAttributes.getLastModifiedMillis());
				} catch (RMIRuntimeException e) {
					return true;
				}
			}
		};
	}

	@Override
	public String getIdentifier() {
		return identifier;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((jarPath == null) ? 0 : jarPath.hashCode());
		result = prime * result + ((rootFileProviderKey == null) ? 0 : rootFileProviderKey.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		JarFileClassPathLocation other = (JarFileClassPathLocation) obj;
		if (jarPath == null) {
			if (other.jarPath != null)
				return false;
		} else if (!jarPath.equals(other.jarPath))
			return false;
		if (rootFileProviderKey == null) {
			if (other.rootFileProviderKey != null)
				return false;
		} else if (!rootFileProviderKey.equals(other.rootFileProviderKey))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return getClass().getSimpleName() + "[" + jarPath + "]";
	}

	protected static class LocationRMIWrapper implements RMIWrapper {
		private JarFileClassPathLocation location;

		public LocationRMIWrapper() {
		}

		public LocationRMIWrapper(JarFileClassPathLocation location) {
			this.location = location;
		}

		@Override
		public void writeWrapped(RMIObjectOutput out) throws IOException {
			out.writeObject(location.jarPath);
			out.writeSerializedObject(location.rootFileProviderKey);
			out.writeRemoteObject(location.fileProvider);
			out.writeUTF(location.identifier);
		}

		@Override
		public void readWrapped(RMIObjectInput in) throws IOException, ClassNotFoundException {
			SakerPath jarpath = (SakerPath) in.readObject();
			RootFileProviderKey rootfpk = (RootFileProviderKey) in.readObject();
			SakerFileProvider fp = (SakerFileProvider) in.readObject();
			String identifier = in.readUTF();
			location = new JarFileClassPathLocation(jarpath, rootfpk, fp, identifier);
		}

		@Override
		public Object getWrappedObject() {
			throw new UnsupportedOperationException();
		}

		@Override
		public Object resolveWrapped() {
			return location;
		}
	}
}
